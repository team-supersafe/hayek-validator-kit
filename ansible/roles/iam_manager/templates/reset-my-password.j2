#!/usr/bin/env bash
# Change the calling user's password only, protected by a per-user security question.
# Enhanced security version with iterated hashing, input validation, and rate limiting
# Generated for {{ ansible_hostname }} on {{ ansible_date_time.iso8601 }}
set -euo pipefail

SEC_DIR={{ password_security_dir | default('/etc/password-security') }}
FILE="$SEC_DIR/$SUDO_USER"
MAX_ATTEMPTS={{ password_max_attempts | default(3) }}
ITERATIONS={{ password_iterations | default(1000) }}
SYSTEM_INFO="{{ ansible_distribution }} {{ ansible_distribution_version }}"
LOG_FILE="{{ password_audit_log | default('/var/log/password-reset.log') }}"

{% raw %}# ISO 27001 Compliant Logging Function with safer IP detection
log_event() {
    local event_type="$1"
    local message="$2"
    local status="${3:-INFO}"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local session_id=$(echo "$SUDO_USER-$(date +%s)" | sha256sum | cut -c1-8)

    # Enhanced IP detection with multiple fallback methods
    local client_ip="unknown"

    # Method 1: SSH environment variables (most reliable for SSH connections)
    if [[ -n "${SSH_CLIENT:-}" ]]; then
        client_ip=$(printf '%s' "$SSH_CLIENT" | cut -d' ' -f1)
    elif [[ -n "${SSH_CONNECTION:-}" ]]; then
        client_ip=$(printf '%s' "$SSH_CONNECTION" | cut -d' ' -f1)
    # Method 2: Check SSH_CONNECTION from parent process
    elif [[ -n "${SSH_CONNECTION:-}" ]] || [[ -n "${SSH_CLIENT:-}" ]]; then
        client_ip=$(env | grep -E 'SSH_(CLIENT|CONNECTION)' | head -1 | cut -d'=' -f2 | cut -d' ' -f1)
    # Method 3: Use who command with safer parsing
    elif command -v who >/dev/null 2>&1; then
        client_ip=$(who am i 2>/dev/null | awk '{print $5}' | sed 's/[()]//g' | head -1)
        # Validate IP format
        if [[ ! "$client_ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]] && [[ ! "$client_ip" =~ ^[0-9a-fA-F:]+$ ]]; then
            client_ip="unknown"
        fi
    # Method 4: Check last command for SSH connections
    elif command -v last >/dev/null 2>&1; then
        client_ip=$(last -1 "$SUDO_USER" 2>/dev/null | grep -v "still logged in" | awk '{print $3}' | head -1)
        if [[ "$client_ip" == "console" ]] || [[ "$client_ip" == "pts"* ]]; then
            client_ip="local"
        fi
    fi

    # Final validation - if still unknown, try to get from parent process
    if [[ "$client_ip" == "unknown" ]] && [[ -n "${SSH_CONNECTION:-}" ]]; then
        client_ip=$(echo "$SSH_CONNECTION" | cut -d' ' -f1 2>/dev/null || echo "unknown")
    fi

    # Log to file with ISO 27001 format
    printf '[%s] [%s] [SESSION:%s] [USER:%s] [TYPE:%s] [IP:%s] %s\n' \
        "$timestamp" "$status" "$session_id" "$SUDO_USER" "$event_type" "$client_ip" "$message" | \
        tee -a "$LOG_FILE" > /dev/null

    # Also log to syslog for centralized monitoring
    logger -t "password-reset" "SESSION:$session_id USER:$SUDO_USER TYPE:$event_type $message"
}

# Secure password hashing function using system utilities
hash_password() {
    local password="$1"
    local salt="${2:-$(generate_salt)}"

    if command -v openssl >/dev/null 2>&1; then
        # Use SHA512-crypt via openssl passwd
        openssl passwd -6 -salt "$salt" "$password"
    elif command -v mkpasswd >/dev/null 2>&1; then
        # Use mkpasswd with argon2 if available
        # Check if mkpasswd supports argon2
        if mkpasswd --help 2>&1 | grep -q 'argon2'; then
            # Use mkpasswd with argon2 if available
            mkpasswd --method=argon2 --salt="$salt" "$password"
        else
            # Fallback to SHA-512 crypt if argon2 is not available
            mkpasswd --method=sha-512 --salt="$salt" "$password"
        fi
    else
        echo "Error: No secure password hashing utility found (openssl or mkpasswd required)." >&2
        return 1
    fi
}

# Generate longer salt (256 bits) with fallback methods
generate_salt() {
    # Try multiple sources for entropy
    if command -v openssl >/dev/null 2>&1; then
        openssl rand -hex 32
    elif [[ -r /dev/urandom ]]; then
        head -c 32 /dev/urandom | xxd -p -c 32
    elif [[ -r /dev/random ]]; then
        head -c 32 /dev/random | xxd -p -c 32
    else
        # Fallback to date + process ID (less secure but functional)
        printf '%s-%s-%s' "$(date +%s)" "$$" "$RANDOM" | sha256sum | cut -c1-64
    fi
}

# Generate encryption key for AES-256
generate_encryption_key() {
    # Generate a 256-bit key (32 bytes) for AES-256
    if command -v openssl >/dev/null 2>&1; then
        openssl rand -hex 32
    elif [[ -r /dev/urandom ]]; then
        head -c 32 /dev/urandom | xxd -p -c 32
    elif [[ -r /dev/random ]]; then
        head -c 32 /dev/random | xxd -p -c 32
    else
        printf '%s-%s-%s-%s' "$(date +%s)" "$$" "$RANDOM" "$SECONDS" | sha256sum | cut -c1-64
    fi
}

# Encrypt data using AES-256-GCM
encrypt_data() {
    local plaintext="$1"
    local key="$2"

    if command -v openssl >/dev/null 2>&1; then
        # Generate IV for this encryption
        local iv=$(openssl rand -hex 16)

        # Encrypt with AES-256-CBC
        local encrypted=$(printf '%s' "$plaintext" | openssl enc -aes-256-cbc -a -A -K "$key" -iv "$iv" 2>/dev/null)

        if [[ $? -eq 0 ]] && [[ -n "$encrypted" ]]; then
            # Return format: iv:encrypted_data
            printf '%s:%s' "$iv" "$encrypted"
        else
            # If AES-256-GCM fails, try AES-256-CBC as fallback
            local encrypted_cbc=$(printf '%s' "$plaintext" | openssl enc -aes-256-cbc -a -A -K "$key" -iv "$iv" 2>/dev/null)
            if [[ $? -eq 0 ]] && [[ -n "$encrypted_cbc" ]]; then
                printf '%s:%s' "$iv" "$encrypted_cbc"
            else
                return 1
        # Generate IV for this encryption (12 bytes for GCM)
        local iv=$(openssl rand -hex 12)

        # Encrypt with AES-256-GCM (authenticated encryption)
        local encrypted=$(printf '%s' "$plaintext" | openssl enc -aes-256-gcm -a -A -K "$key" -iv "$iv" 2>/dev/null)

        if [[ $? -eq 0 ]] && [[ -n "$encrypted" ]]; then
            # Return format: iv:encrypted_data
            printf '%s:%s' "$iv" "$encrypted"
        else
            return 1
        fi
    else
        # Fallback: simple XOR with key (less secure)
        local result=""
        local key_len=${#key}
        for ((i=0; i<${#plaintext}; i++)); do
            local char="${plaintext:$i:1}"
            local key_char="${key:$((i % key_len)):1}"
            local char_code=$(printf '%d' "'$char")
            local key_code=$(printf '%d' "'$key_char")
            local xor_code=$((char_code ^ key_code))
            result+=$(printf '\\x%02x' $xor_code)
        done
        # No strong encryption available; fail gracefully
        echo "Error: No strong encryption tool (OpenSSL) available. Cannot encrypt data securely." >&2
        return 1
    fi
}

# Decrypt data using AES-256-GCM
decrypt_data() {
    local encrypted_data="$1"
    local key="$2"

    if command -v openssl >/dev/null 2>&1; then
        # Split iv:encrypted_data
        local iv="${encrypted_data%%:*}"
        local encrypted="${encrypted_data#*:}"

        # Decrypt with AES-256-CBC
        local decrypted=$(printf '%s' "$encrypted" | openssl enc -aes-256-cbc -d -a -A -K "$key" -iv "$iv" 2>/dev/null)
        if [[ $? -eq 0 ]] && [[ -n "$decrypted" ]]; then
            printf '%s' "$decrypted"
        else
            return 1
        fi
    else
        # Fallback: reverse XOR operation
        local base64_data=$(echo "$encrypted_data" | base64 -d 2>/dev/null)
        local result=""
        local key_len=${#key}
        for ((i=0; i<${#base64_data}; i+=2)); do
            local hex_code="${base64_data:$i:2}"
            local char_code=$((16#$hex_code))
            local key_char="${key:$((i/2 % key_len)):1}"
            local key_code=$(printf '%d' "'$key_char")
            local xor_code=$((char_code ^ key_code))
            result+=$(printf '\\x%02x' $xor_code)
        done
        printf '%s' "$result"
    fi
}

# Enhanced input validation with better sanitization
validate_input() {
    local input="$1"
    local min_length="${2:-6}"

    if [[ ${#input} -lt $min_length ]]; then
        return 1
    fi

    # Whitelist: allow alphanumerics, spaces, and safe punctuation
    # Safe characters: letters, numbers, space, period, comma, question mark, exclamation, hyphen, underscore
    local allowed_pattern='^[-a-zA-Z0-9 .,?!_]+$'
    if ! [[ "$input" =~ $allowed_pattern ]]; then
        echo "Invalid characters detected. Only letters, numbers, spaces, and basic punctuation (.,?!_-) are allowed."
        return 1
    fi

    # Check for control characters
    if [[ "$input" =~ [[:cntrl:]] ]]; then
        return 1
    fi

    return 0
}

# Atomic file creation with proper error handling
create_secure_file() {
    local temp_file
    temp_file=$(mktemp "$SEC_DIR/.tmp.XXXXXXXXXX")

    # Ensure temp file is secure
    chmod 600 "$temp_file"

    # Write content to temp file
    printf '%s\n' "$1" > "$temp_file"

    # Atomic move
    mv "$temp_file" "$2"
}

# Ensure the directory exists with correct permissions atomically
if [[ ! -d "$SEC_DIR" ]]; then
    mkdir -p "$SEC_DIR"
    chmod 700 "$SEC_DIR"
fi

# Check for user lockout (24-hour block or until admin intervention)
# Hash the username to prevent path manipulation
USER_HASH=$(echo -n "$SUDO_USER" | sha256sum | awk '{print $1}')
BLOCK_FILE="/etc/password-security/password-reset-blocked-$USER_HASH"
if [[ -f "$BLOCK_FILE" ]]; then
    BLOCK_UNTIL=$(cat "$BLOCK_FILE")
    CURRENT_TIME=$(date +%s)

    if [[ $CURRENT_TIME -lt $BLOCK_UNTIL ]]; then
        REMAINING=$((BLOCK_UNTIL - CURRENT_TIME))
        HOURS=$((REMAINING / 3600))
        MINUTES=$(((REMAINING % 3600) / 60))

        echo "Account temporarily locked due to multiple failed attempts."
        if [[ $HOURS -gt 0 ]]; then
            echo "Lock expires in $HOURS hours and $MINUTES minutes."
        else
            echo "Lock expires in $MINUTES minutes."
        fi
        echo "Contact administrator for immediate unlock."

        log_event "BLOCKED_ACCESS" "User attempted access while blocked - $HOURS hours $MINUTES minutes remaining"
        exit 1
    else
        # Block expired, remove file
        rm -f "$BLOCK_FILE"
        log_event "BLOCK_EXPIRED" "User block expired, access restored"
    fi
fi

# ISO 27001: Log session start
log_event "SESSION_START" "Password reset process initiated"

# First-time run - ask user to create a question + answer
if [[ ! -f "$FILE" ]]; then
  echo "First-time setup: create your personal security question."

  log_event "FIRST_TIME_SETUP" "User creating initial security question"

  # Validate question input
  while true; do
    read -rp " Question (min 10 chars): " question
    if validate_input "$question" 10; then
      log_event "QUESTION_CREATED" "Security question created successfully"
      break
    else
      echo "Question must be at least 10 characters."
      log_event "QUESTION_VALIDATION_FAILED" "Invalid question format attempted"
    fi
  done

  # Validate answer input
  while true; do
    read -srp " Answer (min 6 chars, will not echo): " answer1 || true
    echo
    read -srp " Repeat answer: " answer2 || true
    echo

    if [[ "$answer1" == "$answer2" ]]; then
      if validate_input "$answer1" 6; then
        log_event "ANSWER_CREATED" "Security answer created successfully"
        break
      else
        echo "Answer must be at least 6 characters."
        log_event "ANSWER_VALIDATION_FAILED" "Invalid answer format attempted"
      fi
    else
      echo "Answers don't match. Try again."
      log_event "ANSWER_MISMATCH" "Answer confirmation mismatch"
    fi
  done

  # Generate encryption key and salt
  encryption_key=$(generate_encryption_key)
  salt=$(generate_salt)
  hash=$(hash_password "$answer1" "$salt")

  # Encrypt the security question
  encrypted_question=$(encrypt_data "$question" "$encryption_key")
  if [[ $? -ne 0 ]]; then
    log_event "ENCRYPTION_FAILED" "Failed to encrypt security question"
    echo "Error: Failed to encrypt security question. Please try again."
    exit 1
  fi

  log_event "QUESTION_ENCRYPTED" "Security question encrypted with AES-256"

  # Store encrypted question, salt, hash, and iteration count using atomic operation
  create_secure_file "$encrypted_question,$salt,$hash,$ITERATIONS,$encryption_key" "$FILE"
  echo "Security question saved with AES-256 encryption and enhanced security ($ITERATIONS iterations)."

  log_event "SECURITY_QUESTION_SAVED" "Security question and answer stored successfully"
else
  # Validate answer with rate limiting
  attempts=0
  log_event "PASSWORD_RESET_ATTEMPT" "Password reset process started"

  # Read the security file once
  IFS=',' read -r encrypted_question salt hash stored_iterations encryption_key < "$FILE"

  # Decrypt the security question once
  question=$(decrypt_data "$encrypted_question" "$encryption_key")
  if [[ $? -ne 0 ]] || [[ -z "$question" ]]; then
    log_event "DECRYPTION_FAILED" "Failed to decrypt security question"
    echo "Error: Failed to decrypt security question. Contact administrator."
    exit 1
  fi

  log_event "QUESTION_DECRYPTED" "Security question decrypted successfully"

  # Show partially hidden question for privacy
  echo "Security check: ${question:0:20}..."

  while [[ $attempts -lt $MAX_ATTEMPTS ]]; do
    read -srp " Answer: " answer || true
    echo

    # Verify with secure hash function
    test_hash=$(hash_password "$answer" "$salt")

    if [[ "$test_hash" == "$hash" ]]; then
      log_event "SECURITY_QUESTION_PASSED" "Security question answered correctly"
      break
    else
      attempts=$((attempts + 1))
      remaining=$((MAX_ATTEMPTS - attempts))
      echo "Incorrect answer. $remaining attempts remaining."

      log_event "SECURITY_QUESTION_FAILED" "Incorrect answer attempt $attempts/$MAX_ATTEMPTS"

      if [[ $attempts -eq $MAX_ATTEMPTS ]]; then
        # Block user for 24 hours (86400 seconds)
        BLOCK_UNTIL=$(( $(date +%s) + 86400 ))
        echo "$BLOCK_UNTIL" > "$BLOCK_FILE"

        log_event "MAX_ATTEMPTS_EXCEEDED" "Maximum attempts exceeded - user blocked for 24 hours"
        echo "Too many failed attempts. Account locked for 24 hours."
        echo "Contact administrator for immediate unlock."
        exit 1
      fi

      # Add delay to prevent brute force attacks
      sleep 2

      # Continue to next iteration
      continue
    fi
  done
fi

# ISO 27001: Log password change attempt
log_event "PASSWORD_CHANGE_ATTEMPT" "Initiating password change process"

# Change the password (no old-pw prompt because we run as root)
if /usr/bin/passwd "$SUDO_USER"; then
    log_event "PASSWORD_CHANGE_SUCCESS" "Password changed successfully"
else
    log_event "PASSWORD_CHANGE_FAILED" "Password change failed"
    exit 1
fi

# ISO 27001: Log session end
log_event "SESSION_END" "Password reset process completed successfully"{% endraw %}
