#!/usr/bin/env bash
# Change the calling user's password only, protected by a per-user security question.
# Enhanced security version with iterated hashing, input validation, and rate limiting
# Generated for {{ ansible_hostname }} on {{ ansible_date_time.iso8601 }}
set -euo pipefail

SEC_DIR={{ password_security_dir | default('/etc/password-security') }}
FILE="$SEC_DIR/$SUDO_USER"
MAX_ATTEMPTS={{ password_max_attempts | default(3) }}
ITERATIONS={{ password_iterations | default(1000) }}
SYSTEM_INFO="{{ ansible_distribution }} {{ ansible_distribution_version }}"
LOG_FILE="{{ password_audit_log | default('/var/log/password-reset.log') }}"

{% raw %}# ISO 27001 Compliant Logging Function
log_event() {
    local event_type="$1"
    local message="$2"
    local status="${3:-INFO}"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local session_id=$(echo "$SUDO_USER-$(date +%s)" | sha256sum | cut -c1-8)

    # Log to file with ISO 27001 format
    echo "[$timestamp] [$status] [SESSION:$session_id] [USER:$SUDO_USER] [TYPE:$event_type] [IP:$(who am i | awk '{print $5}' | sed 's/[()]//g')] $message" | tee -a "$LOG_FILE" > /dev/null

    # Also log to syslog for centralized monitoring
    logger -t "password-reset" "SESSION:$session_id USER:$SUDO_USER TYPE:$event_type $message"
}

# Enhanced hashing function with iterations
sha256_iterated() {
    local input="$1"
    local iterations="${2:-$ITERATIONS}"

    local hash="$input"
    for ((i=0; i<iterations; i++)); do
        hash=$(printf %s "$hash" | sha256sum | awk '{print $1}')
    done
    echo "$hash"
}

# Generate longer salt (256 bits instead of 64)
generate_salt() {
    openssl rand -hex 32
}

# Validate input format - simplified to avoid regex issues
validate_input() {
    local input="$1"
    local min_length="${2:-6}"

    if [[ ${#input} -lt $min_length ]]; then
        return 1
    fi

    # Simple validation - check for common dangerous characters
    if [[ "$input" == *"'"* ]]; then
        return 1
    fi
    if [[ "$input" == *'"'* ]]; then
        return 1
    fi
    if [[ "$input" == *"\\"* ]]; then
        return 1
    fi
    if [[ "$input" == *"\`"* ]]; then
        return 1
    fi

    return 0
}

# Ensure the directory exists with correct permissions from the start (fix race condition)
mkdir -p -m 700 "$SEC_DIR"

# ISO 27001: Log session start
log_event "SESSION_START" "Password reset process initiated"

# First-time run - ask user to create a question + answer
if [[ ! -f "$FILE" ]]; then
  echo "First-time setup: create your personal security question."
  echo "System: $SYSTEM_INFO"

  log_event "FIRST_TIME_SETUP" "User creating initial security question"

  # Validate question input
  while true; do
    read -rp " Question (min 10 chars): " question
    if validate_input "$question" 10; then
      log_event "QUESTION_CREATED" "Security question created successfully"
      break
    else
      echo "Question must be at least 10 characters and avoid quotes, backslashes, and backticks"
      log_event "QUESTION_VALIDATION_FAILED" "Invalid question format attempted"
    fi
  done

  # Validate answer input
  while true; do
    read -srp " Answer (min 6 chars, will not echo): " answer1 && echo
    read -srp " Repeat answer: " answer2 && echo

    if [[ "$answer1" == "$answer2" ]]; then
      if validate_input "$answer1" 6; then
        log_event "ANSWER_CREATED" "Security answer created successfully"
        break
      else
        echo "Answer must be at least 6 characters and avoid quotes, backslashes, and backticks"
        log_event "ANSWER_VALIDATION_FAILED" "Invalid answer format attempted"
      fi
    else
      echo "Answers don't match. Try again."
      log_event "ANSWER_MISMATCH" "Answer confirmation mismatch"
    fi
  done

  # Generate longer salt and iterated hash
  salt=$(generate_salt)
  hash=$(sha256_iterated "$answer1$salt" "$ITERATIONS")

  # Store with iteration count for future verification
  printf '%s,%s,%s,%d\n' "$question" "$salt" "$hash" "$ITERATIONS" | tee "$FILE" > /dev/null
  chmod 600 "$FILE"
  echo "Security question saved with enhanced security ($ITERATIONS iterations)."

  log_event "SECURITY_QUESTION_SAVED" "Security question and answer stored successfully"
else
  # Validate answer with rate limiting
  attempts=0
  log_event "PASSWORD_RESET_ATTEMPT" "Password reset process started"

  while [[ $attempts -lt $MAX_ATTEMPTS ]]; do
    IFS=',' read -r question salt hash stored_iterations < "$FILE"

    # Show partially hidden question for privacy
    echo "Security check: ${question:0:20}..."
    read -srp " Answer: " answer && echo

    # Verify with stored iteration count
    if [[ $(sha256_iterated "$answer$salt" "$stored_iterations") == "$hash" ]]; then
      log_event "SECURITY_QUESTION_PASSED" "Security question answered correctly"
      break
    else
      ((attempts++))
      remaining=$((MAX_ATTEMPTS - attempts))
      echo "Incorrect answer. $remaining attempts remaining."

      log_event "SECURITY_QUESTION_FAILED" "Incorrect answer attempt $attempts/$MAX_ATTEMPTS"

      if [[ $attempts -eq $MAX_ATTEMPTS ]]; then
        log_event "MAX_ATTEMPTS_EXCEEDED" "Maximum attempts exceeded - access denied"
        echo "Too many failed attempts. Contact administrator."
        exit 1
      fi

      # Add delay to prevent brute force attacks
      sleep 2
    fi
  done
fi

# ISO 27001: Log password change attempt
log_event "PASSWORD_CHANGE_ATTEMPT" "Initiating password change process"

# Change the password (no old-pw prompt because we run as root)
if /usr/bin/passwd "$SUDO_USER"; then
    log_event "PASSWORD_CHANGE_SUCCESS" "Password changed successfully"
else
    log_event "PASSWORD_CHANGE_FAILED" "Password change failed"
    exit 1
fi

# ISO 27001: Log session end
log_event "SESSION_END" "Password reset process completed successfully"{% endraw %}
